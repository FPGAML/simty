from PIL import Image
import numpy as np
import argparse

# When used with data generated by Arthur Blanleuil's Rust-based RISC-V simulator,
# this constant must be set to true, because the formatting is different
IS_ARTHUR = False

# This function reads the output from the testio RAM, assuming the data are written
# from the first address in the RAN. This is why first_line is set to 0.
# If you want to read from a speific section of testio, then adjust first_line accordingly,
# and maybe turn it into an argument for this function and the script itself.
# For now, it's probably more user-friendly to have it hard-coded here.
def get_raw_values(path, width, height):
	raw_values = []
	img_path = path
	with open(img_path, "r") as infile:
		lnum = 0
		first_line = 0
		last_line = first_line + width*height
		for line in infile:
			if first_line <= lnum and lnum < last_line:
				# Values in the output produced by Simty have four 32-bit words per line,
				# high addresses first. So the first line will have the words at addresses
				# 3, 2, 1, 0, the second line will have those at 7, 6, 5, 4, etc.
				# Therefore, you have to read each line from right to left, not left to right.
				line = line.rstrip('\n')
				raw_values.append(line[24:])
				raw_values.append(line[16:24])
				raw_values.append(line[8:16])
				raw_values.append(line[:8])
			lnum += 1
	return(raw_values)

# Same function as the standard get_raw_values, but written for data generated
# by Arthur's simulator. It's similar, just a bit simpler.
def get_raw_values_arthur(path, width, height):
	raw_values = []
	img_path = path
	with open(img_path, "r") as infile:
		lnum = 0
		first_line = 0
		last_line = first_line + width*height
		for line in infile:
			if first_line <= lnum and lnum < last_line:
				line = line.rstrip('\n')
				raw_values.append(line)
			lnum += 1
	return(raw_values)

# This function creates is meant to create an image.
# It starts with an array of height * width * 4 elements.
# You have 4 elements for each i * j combination where i is a height and j is a width,
# because there are 4 components per pixel in the RBGA format.
# So it reads all the values in raw_values, and interprets ones as white pixels,
# zeros as black ones. So it fills the array accordingly, and returns it.
def fill_img_array(raw_values, width, height):
	img_array = np.zeros( (height,width,4), dtype=np.uint8 )
	cnt = 0
	for i in range(height):
		for j in range(width):
			intval = int(raw_values[cnt], 16)
			if intval == 1: # threshold above which the sequence diverges
				r,g,b,a = 255, 255, 255, 255
			else:
				r,g,b,a = 0,0,0,255
			img_array[i,j] = r,g,b,a
			cnt +=1
	return(img_array)

# This just creates an actual image from the numpy array, and saves it to mandelbrot_pic.png
def save_img(img_array, save_path):
	img = Image.fromarray(img_array, 'RGBA')
	img.save(save_path)
	print("Saved result image as: " + save_path)


def main():
	parser = argparse.ArgumentParser(description='This script is designed to test the output of the Mandelbrot \
	program by creating a PNG image from sequence of HEX values. In practice, it can do so from any sequence of \
	HEX values in the appropriate format, i.e. 32 HEX characters per line.')
	parser.add_argument('in_path', help='the path to the sequence of HEX values, e.g. result.res')
	parser.add_argument('out_path', help='the path to the PNG image to be generated, e.g. mandelbrot_pic.png')
	parser.add_argument('width', type=int, help='the width of the image to be created, in pixels, e.g. 31')
	parser.add_argument('height', type=int, help='the height of the image to be created, in pixels, e.g. 21')
	args = parser.parse_args()

	if IS_ARTHUR:
		raw_values = get_raw_values_arthur(args.in_path, args.width, args.height)
	else:
		raw_values = get_raw_values(args.in_path, args.width, args.height)

	img_array = fill_img_array(raw_values, args.width, args.height)
	save_img(img_array, args.out_path)


if __name__ == "__main__":
    main()
